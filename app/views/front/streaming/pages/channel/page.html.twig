<div class=" w-full  lg:h-screen gradient-top-overlay" style="min-height: 300px; max-height: calc(100vh - 70px)">


	<figure id="channelContainer" class="w-full  shadow-xl absolute top-0 left-0 ">
		<video id="channelPlayer" data-container="channelContainer" class="w-full h-screen" autoplay poster="/stream?thumbnail=1000&image={{item.picture_name}}" crossorigin="anonymous" >
			<source src="/stream_channel?channel_id={{item.channel_id}}" type="video/webm"/>
			<source src="/stream_channel?channel_id={{item.channel_id}}" type="video/mp4"/>
		</video>

		<div id="channel-controls" class="flex px-6 gap-4 text-gray-400 absolute bottom-0 left-0 w-full gradient-top-overlay pt-10" data-state="hidden">
			<button class="play-channel brightness-200 w-full"  data-player="channelPlayer" id="play" type="button" data-state="play"><img src="/src/front_assets/svg/video-play.svg" class="w-4 brightness-200"/></button>
			<button class="pause-channel brightness-200 w-full"  data-player="channelPlayer" style="display:none" id="pause" type="button" data-state="pause"><img src="/src/front_assets/svg/video-pause.svg" class="w-4 brightness-200"/></button>

            <div class="flex gap-4 flex-end">
                <div class="volume relative show-child flex-none">
                    <button class="brightness-200" id="mute"  data-player="channelPlayer" type="button" style="padding-top: 5px" data-state="mute"><img src="/src/front_assets/svg/video-volume.svg" class="w-4 brightness-200"/></button>
                    <input type="range" id="channel-volume"  data-player="channelPlayer" min="0" step=".1" max="1" class="show-on-hover absolute bottom-0 h-2 left-1 w-20" style="transform-origin: left; transform: rotate(270deg);"/>
                </div>
                <button id="fs" class="fullscreen " id="pause"  data-container="channelContainer" type="button" data-state="go-fullscreen"><img src="/src/front_assets/svg/fullscreen.svg" class="w-4 brightness-200"/></button>
            </div>
		</div>
	</figure>

</div>
<div class=" w-full h-40 absolute top-0 left-0 gradient-overlay" style="z-index:1; "></div>

{% set customer = app.customer_auth() %}
<div class=" w-full  relative" id="video-overlay">
	<div class="absolute lg:bottom-40 lg:left-40 left-10 bottom-10  z-10 w-2/3 text-gray-100 dark:text-gray-400">
		<h1 class="lg:text-4xl text-2xl text-white overflow-hidden">{{item.name}}</h1>

		{% if item.customer_id == customer.customer_id %}
			<div class="{{ following == null ? '' : ' hidden'}} float-right" x-on:click="jQuery('#heart-{{item.customer_id}}').addClass('hidden'); jQuery('#unheart-{{item.customer_id}}').removeClass('hidden')" id="heart-{{item.customer_id}}">
				<a href="/studio" class="ajax-load hover:border-orange-300 hover:text-orange-300 border  border border-4 border-white rounded-full py-2 px-6">
					<span>{{lang.translate('Edit')}}</span>
				</a>
			</div>
		{% else  %}
        
		{% endif %}

		<div class="w-full flex gap-4 ">

			<span class="text-sm text-gray-100">{{lang.translate('Likes')}} : {{item.likes|length}} </span>
			<span class="text-sm text-gray-100">{{lang.translate('Comments')}} : {{item.comments|length}} </span>
			<span x-on:click="jQuery('#share-popup').removeClass('hidden')" class="cursor-pointer mx-2 text-sm text-gray-100"><img src="/src/front_assets/svg/share.svg" class="w-5"></span>

		</div>

	</div>
</div>
<div class="pb-4  h-full overflow-hidden rounded-2xl" x-data="{is_slide: 'slide'}">

	<div class="relative z-10 w-full  gap-4 bg-white dark:bg-gray-900 rounded-2xl p-8 h-full">

		<span class="block pt-10 text-sm text-gray-500">{{lang.translate('About')}}</span>
		<div class="text-primary overflow-auto" style="max-height: 400px;">
			<div class="dark:text-gray-400 py-4">{{item.field.about|raw| nl2br  }}</div>
		</div>

	</div>

</div>


<script  type="text/javascript">
// var lastId;
$(function()  {

    const channelPlayer = document.getElementById('channelPlayer');
    const bufferingIndicator = document.getElementById('bufferingIndicator');
    let mediaSource;
    let sourceBuffer;
    let isSourceOpen = false;

    function fetchCurrentVideoInfo(channelId) {

        fetch(`/channel_json/`+channelId)
            .then(response => response.json())
            .then(data => {
                if (data) {
                    activeChannel = data
                    activeChannelMedia = data.active_item
                    loadVideoPartially();
                } else {
                    console.log('No video currently playing');
                }
            })
            .catch(error => console.error('Error:', error));
    }

    function loadVideoPartially() {
        
        if (!activeChannelMedia) {
            console.log('empty' )
            return ;
        }

        var a = new Date(activeChannelMedia.start);
        var b = new Date();
        var startPosition = parseInt((b - a) / 1000);
        // var startPosition = 130;

        const videoUrl = '/stream_channel?channel_id='+activeChannel.channel_id;
        
        if (mediaSource) {
            if (mediaSource.readyState === 'open') {
                mediaSource.endOfStream();
            }
            URL.revokeObjectURL(channelPlayer.src);
        }

        mediaSource = new MediaSource();
        channelPlayer.src = URL.createObjectURL(mediaSource);

        mediaSource.addEventListener('sourceopen', function() {
            isSourceOpen = true;
            sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
            sourceBuffer.mode = 'segments';
            
            fetchInitSegment(videoUrl).then(() => {
                channelPlayer.currentTime = startPosition;
            });

            channelPlayer.addEventListener('seeking', onSeeking);
        });

        mediaSource.addEventListener('sourceended', function() {
            isSourceOpen = false;
        });
        setTimeout(function(){
    		channelPlayer.play()
        }, 500)
    }

    function fetchInitSegment(url) {
        return fetch(url, { headers: { 'Range': 'bytes=0-' } })
            .then(response => response.arrayBuffer())
            .then(data => {
                sourceBuffer.appendBuffer(data);
                return new Promise(resolve => {
                    sourceBuffer.addEventListener('updateend', resolve, { once: false });
                });
            });
    }

    function onSeeking() {
        const currentTime = channelPlayer.currentTime;
        const buffered = channelPlayer.buffered;

        if (isTimeBuffered(currentTime, buffered)) {
            return;
        }

        bufferingIndicator.style.display = 'block';
        abortCurrentRequests();
        fetchSegmentAtTime(channelPlayer.currentTime);
    }

    function isTimeBuffered(time, buffered) {
        for (let i = 0; i < buffered.length; i++) {
            if (time >= buffered.start(i) && time <= buffered.end(i)) {
                return true;
            }
        }
        return false;
    }

    function abortCurrentRequests() {
        // Implement logic to abort any ongoing fetch requests
    }

    function fetchSegmentAtTime(time) {
        // In a real implementation, you would calculate the byte range for the segment containing 'time'
        // This is a simplified version
        const estimatedByteOffset = Math.floor(time * 1000000); // Very rough estimate
        
        fetch(channelPlayer.src, {
            headers: { 'Range': `bytes=${estimatedByteOffset}-` }
        })
        .then(response => response.arrayBuffer())
        .then(data => {
            sourceBuffer.appendBuffer(data);
            bufferingIndicator.style.display = 'none';
        })
        .catch(error => {
            console.error('Error fetching video segment:', error);
            bufferingIndicator.style.display = 'none';
        });
    }

    // Fetch Channel info when the page loads
    fetchCurrentVideoInfo({{item.channel_id}});

    
    window.navigation.addEventListener("navigate", (event) => {
        clearInterval(stationCommentsInterval)
        window.navigation.removeEventListener("navigate", function(){})
    })

    let stationIntervalAmount = jQuery('#startions-interval').val();
    var stationCommentsInterval = setInterval(async function(){

        // Periodically check for updates (e.g., every 5 minutes)
        fetchCurrentVideoInfo({{item.channel_id}});
	}, stationIntervalAmount > 1  ? (stationIntervalAmount * 1000) : 60000);

});
</script>