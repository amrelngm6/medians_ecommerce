<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TV Channel Player with Controlled Chunk Loading</title>
</head>
<body>
    <video id="videoPlayer" controls>
        Your browser does not support the video tag.
    </video>
    <div id="bufferingIndicator" style="display: none;">Buffering...</div>

    <script>
        const videoPlayer = document.getElementById('videoPlayer');
        const bufferingIndicator = document.getElementById('bufferingIndicator');
        const channelId = 1; // Replace with the desired channel ID
        let mediaSource;
        let sourceBuffer;
        let isSourceOpen = false;
        let isFetching = false;
        let currentVideoUrl = '';
        let totalSize = 0;
        let loadedBytes = 0;

        function fetchCurrentVideoInfo() {
            fetch(`/channel_json/`+channelId)
                .then(response => response.json())
                .then(data => {
                    if (data) {
                        loadVideoPartially(data.active_item);
                    } else {
                        console.log('No video currently playing');
                    }
                })
                .catch(error => console.error('Error:', error));
        }

        function loadVideoPartially(media) {
            
            var a = new Date(media.start);
            var b = new Date();
            var startPosition = parseInt((b - a) / 1000);
            var startPosition = parseInt(((b - a) / 1000) - 3600);

            const videoUrl = media.media_path;
            currentVideoUrl = videoUrl;
            
            if (mediaSource) {
                if (mediaSource.readyState === 'open') {
                    mediaSource.endOfStream();
                }
                URL.revokeObjectURL(videoPlayer.src);
            }

            mediaSource = new MediaSource();
            videoPlayer.src = URL.createObjectURL(mediaSource);

            mediaSource.addEventListener('sourceopen', function() {
                isSourceOpen = true;
                sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
                sourceBuffer.addEventListener('updateend', function() {
                    if (mediaSource.readyState === 'open' && !isFetching) {
                        fetchNextChunk();
                    }
                });
                fetchVideoChunk(videoUrl, 0, true);
            });

            mediaSource.addEventListener('sourceended', function() {
                isSourceOpen = false;
            });

            videoPlayer.currentTime = startPosition;
        }

        function fetchVideoChunk(url, startByte, isFirstChunk = false, chunkSize = 1024 * 1024) {
            if (!isSourceOpen || isFetching) {
                return;
            }

            isFetching = true;
            bufferingIndicator.style.display = 'block';

            fetch(url, {
                headers: {
                    'Range': `bytes=${startByte}-${startByte + chunkSize - 1}`
                }
            })
            .then(response => {
                if (isFirstChunk) {
                    const rangeHeader = response.headers.get('Content-Range');
                    if (rangeHeader) {
                        totalSize = parseInt(rangeHeader.split('/')[1], 10);
                    }
                }
                return response.arrayBuffer();
            })
            .then(data => {
                if (isSourceOpen && !sourceBuffer.updating) {
                    try {
                        sourceBuffer.appendBuffer(data);
                        loadedBytes += data.byteLength;
                        if (videoPlayer.readyState >= 3) { // HAVE_FUTURE_DATA or higher
                            videoPlayer.play();
                            bufferingIndicator.style.display = 'none';
                        }
                    } catch (e) {
                        console.error('Error appending buffer:', e);
                        if (e.name === 'QuotaExceededError') {
                            // Remove some data to free up buffer space
                            const currentTime = videoPlayer.currentTime;
                            sourceBuffer.remove(0, currentTime - 30); // Keep 30 seconds in buffer
                        }
                    }
                }
                isFetching = false;
            })
            .catch(error => {
                console.error('Error fetching video chunk:', error);
                isFetching = false;
                bufferingIndicator.style.display = 'none';
            });
        }

        function fetchNextChunk() {
            if (loadedBytes < totalSize) {
                fetchVideoChunk(currentVideoUrl, loadedBytes);
            } else {
                console.log('Video fully loaded');
                bufferingIndicator.style.display = 'none';
            }
        }

        videoPlayer.addEventListener('waiting', function() {
            bufferingIndicator.style.display = 'block';
        });

        videoPlayer.addEventListener('canplay', function() {
            bufferingIndicator.style.display = 'none';
        });

        // Fetch video info when the page loads
        fetchCurrentVideoInfo();

        // Periodically check for updates (e.g., every 5 minutes)
        setInterval(fetchCurrentVideoInfo, 5 * 60 * 1000);
    </script>
</body>
</html>
